---
title: "Curious Case a Dotnet Binary"
excerpt: "Blog explaining the process of reverse engineering a random dotnet sample."
last_modified_at: 2018-01-03T09:45:06-05:00
header:
  teaser: "assets/images/markup-syntax-highlighting-teaser.jpg"
tags: 
  - RE
  - Dotnet
  - Obfuscation
toc: true
---

In this article you will I will show different types of obfuscations applied to several stages of a malware and how to deobfuscate them. The purpose of this blog is to share my hobby for reverse engineering with other via this blog and learn along the way. Feel free to correct me regarding the blog via email. 


### Malware Hunting

Starting this blog I needed some content to put on here, in search of something interested I came across aea3598323131fec106e5e1d64655f84. Going through random malwares on MalwareBazaar.com I stumpled upon this malware tagged as Trickbot.

<figure>
  <img src="{{ '/assets/images/malwarebazaar.png' | relative_url }}" alt="Finding this sample on MalwareBazaar">
</figure>

### Stage 1

Let's look at this malware statically using PeStudio:

<figure>
  <img src="{{ '/assets/images/pestudio1.png' | relative_url }}" alt="Sample disection under Pestudio.">
</figure>


Here we can notice a few things:
- It is a .NET sample (as mentioned already)
- The resource section is quite large in comparison to the sample == Sample is packed with the next stage residing in the resource section

This is what the sample looked like when opened in Dnspy ( a .NET decompiler):

<figure>
  <img src="{{ '/assets/images/sample.png' | relative_url }}" alt="Sample obfuscated.">
</figure>

After doing a bit of research I found out that the sample was obfuscated using eazfuscator. In order to deobfuscate the sample I used this tool call [Eazfixer](https://github.com/holly-hacker/EazFixer).

This is what the sample looked like after using Eazfixer:

<figure>
  <img src="{{ '/assets/images/sample1.png' | relative_url }}" alt="Sample with Eazfixer applied.">
</figure>

We can see in line number 34 how the strings are visible now. But the function and class names are still not redable, for that I used [de4dot](https://github.com/de4dot/de4dot). Applying eazfixer than de4dot did not work very well so I changed the order and applied de4dot first and vice versa. Here is the final look:

<figure>
  <img src="{{ '/assets/images/sample2.png' | relative_url }}" alt="Sample with Eazfixer and de4dot applied.">
</figure>

Now here comes the fun part, we can see InitializeComponent() decrypting a resource and invoking it's function named "Fm.gk":

<figure>
  <img src="{{ '/assets/images/initializecomponent.png' | relative_url }}" alt="Resource decryption and invoking.">
</figure>

I dumped the resource named "Wanted" and ported the code seen above to python to decrypt the binary. Same could be done dynamically, which is more efficient and I will show that method in next stages. Following is the final script used:

```
f = open("/Users/mac/malware-analysis/trickbot/Wanted", "rb")
array = list(f.read())
string = b''
array2 =[
    67, 82, 90, 90, 66, 56, 52, 71, 72, 70,
    70, 72, 66, 52, 55, 89, 66, 65, 70, 56,
    82, 71
]
num = 0
num2 = 74240
for i in range (0, (num2 * (num + 1))-1):
    num3 = i + 1
    num4 = i % num2
    num5 = num3 % num2
    num6 = int(array[num5] + 256)
    num7 = int(array[num4])
    num8 = num7 ^ int(array2[i % 22])
    num9 = num8 - num6
    array[num4] = (num9 % 256).to_bytes()
    string += array[num4]
    i += 1

with open("/Users/mac/malware-analysis/trickbot/Wanted_decoded", "wb") as f:
    f.write(string)
```

Voila I could see the MZ header and we have the stage 2 at our hand now. 

### Stage 2

Stage 2 is also a .NET binary. Here is what stage 2 looks like decompiled using Dnspy:

<figure>
  <img src="{{ '/assets/images/stage2.png' | relative_url }}" alt="Stage2 Obfuscated.">
</figure>

Let's deobfuscate it using our trustee de4dot. Voila:
<figure>
  <img src="{{ '/assets/images/stage2_1.png' | relative_url }}" alt="Stage2 debfuscated.">
</figure>

Look at the same function after deobfuscation and how clean it all is. Here we can see 3 other modules being loaded in the memory, but we are only interested in the last module named "Tyrone". In order to get to this binary I used dynamic method which involves using dnspy debugger to get to the line 846 as seen in screenshot below:

<figure>
  <img src="{{ '/assets/images/stage2_2.png' | relative_url }}" alt="Stage2 debfuscated.">
</figure>

We do have the deobfuscated binary at hand but while debugging we will see the binary in its original obfuscated form and things will look a lot messier, but with the help of the deobfuscated binary we can make sense out of things. In the screenshot above we hit the breakpoint and save the module Tyrone by saving it from Modules window. 

Now we have the stage 3 at our hand, we also need to figure out what functions are called from Tyrone. Following method can be seen invoking 29th method of 20th class:

<figure>
  <img src="{{ '/assets/images/stage2_3.png' | relative_url }}" alt="Stage2 debfuscated.">
</figure>

Using debugger here are those values:
- type == IYyuwfjoC5gtNJv98P.Hfj2Rl3KPdvlPq8KW5
- methodinfo == zLBF9CUeUX

### Stage 3

### Payload

